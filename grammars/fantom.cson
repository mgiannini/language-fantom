# TODO: make much more context-sensitive for pattern matching (class, method, slot, etc)
scopeName: 'source.fantom'
name: 'Fantom'
fileTypes: ['fan']

patterns: [
  {include: '#comments'}
  {include: '#support'}
  {include: '#core'}
]
repository: {
  comments: {
    patterns: [
      {include: '#line_comment'}
      {include: '#fandoc'}
      {include: '#block_comment'}
    ]
  }
  line_comment: {
    patterns: [
      {
        match: '(//).*$\\n?'
        name: 'comment.line.double-slash.fantom'
      }
    ]
  }
  fandoc: {
    patterns: [
      {
        match: '^\\s*\\*\\*.*\\n'
        name: 'comment.block.documentation.fandoc.fantom'
      }
    ]
  }
  block_comment: {
    patterns: [
      {
        name: 'comment.block.nested.fantom'
        begin: '/\\*'
        end: '\\*/'
        patterns: [
          {include: '#block_comment'}
        ]
      }
    ]
  }

  support: {
    patterns: [
      {
        name: 'support.type.builtin.fantom'
        match: "\\b(Void|Bool|Int|Float|Decimal|Duration|Str|Uri|Type|Slot|Range|List|Map|This)\\b"
      }
    ]
  }

  core: {
    patterns: [
      {include: '#literal_number'}
      {include: '#literal_language_constant'}
      {include: '#literal_keywords'}
      {include: '#literal_string'}
      {include: '#literal_uri'}
      {include: '#literal_language_variable'}
    ]
  }

  literal_number: {
    # TODO: come back and clean up these patterns
    patterns: [
      {
        name: 'invalid.illegal.numeric.hex.fantom'
        match: "(?i)(?:\\B[-+]\\b)0x_?[0-9a-f_]*\\.(\\B|\\b[0-9]+)",
      }
      {
        name: 'constant.numeric.fantom'
        match: "(?xi)\n  (?:\\B[-+])?\n  (?:\n    \\b0x[0-9a-f][_0-9a-f]*|                 # hex\n    (\n      \\B\\.[0-9]+|                           # e.g. .999\n      \\b[0-9][_0-9]*(\\.[0-9][_0-9]*[fd]?)?  # e.g. 999.999, 999.9 999\n    )(e[-+]?[0-9][_0-9]*)?                  # scientific notation\n    [fd]?                                   # f/d suffix (e.g. 999f)\n  )\n"
      }
      {
        name: 'constant.numeric.char-literal.fantom'
        match: "(?x)\n  \\'\\\\\n  (\n    u[0-9A-Fa-f]{4}|\n    [bfnrt\"'`$\\\\]\n  )\n  \\'\n"
      }
    ]
  }

  literal_language_constant: {
    patterns: [
      {
        name: 'constant.language.boolean.true.fantom'
        match: '\\btrue\\b'
      }
      {
        name: 'constant.language.boolean.false.fantom'
        match: '\\bfalse\\b'
      }
      {
        name: 'constant.language.null.fantom'
        match: '\\bnull\\b'
      }
    ]
  }

  literal_keywords: {
    patterns: [
      {
        name: 'storage.modifier.fantom'
        match: "\\b(abstract|const|final|internal|native|once|override|private|protected|public|readonly|static|virtual|volatile)\\b"
      }
      {
        name: 'storage.modifier.global.fantom'
        match: '\\busing\\b'
      }
      {
        name: 'storage.type.fantom'
        match: '\\b(class|mixin|enum|facet)\\b'
      }
      {
        name: 'keyword.control.flow.fantom'
        match: '\\b(return|break|continue)\\b'
      }
      {
        name: 'keyword.control.try-catch.fantom'
        match: '\\b(try|catch|finally|throw|assert)\\b'
      }
      {
        name: 'keyword.control.loop.fantom'
        match: '\\b(for|while|do|foreach)\\b'
      }
      {
        name: 'keyword.control.switch.fantom'
        match: '\\b(switch|case|default)\\b'
      }
      {
        name: 'keyword.control.if-else.fantom'
        match: '\\b(if|else)\\b'
      }
      {
        name: 'keyword.operator.named.fantom'
        match: '\\b(new|void|as)\\b'
      }
      {
        match: '(===?|!==?|<=>?|>=|<|>|\\bis(not)?\\b)'
        name: 'keyword.operator.comparison.fantom'
      }
      {
        name: 'keyword.operator.assignment.arithmetic.fantom'
        match: '([+*/%-]=)'
      }
      {
        name: 'keyword.operator.assignment.fantom'
        match: ':?='
      }
      {
        name: 'keyword.operator.increment-decrement.fantom'
        match: '\\-\\-|\\+\\+'
      }
      {
        name: 'keyword.operator.arithmetic.fantom'
        match: '\\-|\\+|\\*|\\/|%'
      }
      {
        name: 'keyword.operator.logical.fantom'
        match: '(!(?!=)|&&|\\|\\|)'
      }
      {
        name: 'keyword.operator.elvis.fantom'
        match: '\\?\\:'
      }
      {
        name: 'keyword.operator.trap.fantom'
        match: '\\->'
      }
      {
        name: 'keyword.operator.safe-trap.fantom'
        match: '\\?\\->'
      }
      {
        name: 'keyword.operator.call.fantom'
        match:'(?<=\\S)\\.(?=\\S)'
      }
      {
        name: 'keyword.operator.safe-call.fantom'
        match: '(?<=\\S)\\?\\.(?=\\S)'
      }
      {
        # This range doesn't parse correctly [x..1] (treats .1 as number)
        name: 'keyword.operator.range.fantom'
        match: '\\.\\.<?'
      }
      {
        # TODO: handle lookahead for start of identifier
        name: 'keyword.operator.address-of.fantom'
        match: '(?x)&'
      }
      {
        name: 'punctuation.terminator.fantom'
        match: ';'
      }
    ]
  }

  literal_language_variable: {
    patterns: [
      {
        name: 'variable.language.super.fantom'
        match: '(?<!\\.)\\b(super)\\b'
      }
      {
        name: 'variable.language.this.fantom'
        match: '(?!\\.)\\b(this)\\b'
      }
      {
        name: 'variable.language.it.fantom'
        match: '(?!\\.)\\b(it)(?=\\.)'
      }
    ]
  }

  literal_string: {
    patterns: [
      {
        name: 'string.quoted.double.fantom'
        begin: '"'
        beginCaptures: {
          0: {name: 'punctuation.definition.string.begin.fantom'}
        }
        end: '"'
        endCaptures: {
          0: {name: 'punctuation.definition.string.end.fantom'}
        }
        patterns: [
          {include: '#escaped_unicode_char'}
          {include: '#escaped_char'}
          {include: '#interpolation'}
        ]
      }
    ]
  }

  literal_uri: {
    patterns: [
      {
        name: 'string.quoted.other.uri.fantom'
        begin: '\\`'
        beginCaptures: {
          0: {name: 'punctuation.definition.uri.begin.fantom'}
        }
        end: '\\`'
        endCaptures: {
          0: {name: 'punctuation.definition.uri.end.fantom'}
        }
        patterns: [
          {include: '#escaped_unicode_char'}
          {include: '#escaped_char'}
          {include: '#interpolation'}
        ]
      }
    ]
  }

  escaped_unicode_char: {
    patterns: [
      {
        name: 'constant.character.unicode.fantom'
        match: '\\\\u[0-9A-Fa-f]{4}'
      }
    ]
  }

  escaped_char: {
    patterns: [
      {
        name: 'constant.character.escapes.fantom'
        match: "\\\\[bfnrt\"'`$\\\\]"
      }
    ]
  }

  interpolation: {
    patterns: [
      {
        name: 'variable.other.interpolated.fantom'
        match: '(?x)\\$(\\{.*?\\}|([A-Za-z_][_\\w]*\\.?)+)'
      }
    ]
  }
}
